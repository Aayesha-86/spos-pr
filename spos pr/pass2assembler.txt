# -------------------------------
# PASS 1: AssemblerPassOne (your original code, unchanged)
# -------------------------------
class SymbolTable:
    def __init__(self):
        self.table = {}

    def add_symbol(self, symbol, address=None):
        if symbol not in self.table:
            self.table[symbol] = address
        elif address is not None:
            self.table[symbol] = address

    def get_address(self, symbol):
        return self.table.get(symbol, 0)

    def display(self):
        print("\nSymbol Table:")
        print("Symbol\tAddress")
        for symbol, addr in self.table.items():
            print(f"{symbol}\t{addr}")


class AssemblerPassOne:
    def __init__(self):
        self.symbol_table = SymbolTable()
        self.intermediate_code = []
        self.locctr = 0

        self.imperative_statements = {
            "MOV": "01",
            "ADD": "02",
            "SUB": "03"
        }

        self.directives = ["START", "END", "ORIGIN", "EQU", "DS", "DC"]

        self.registers = {
            "AREG": "1",
            "BREG": "2",
            "CREG": "3",
            "DREG": "4"
        }

    def process_line(self, label, opcode, operands):
        if label:
            self.symbol_table.add_symbol(label, self.locctr)

        if opcode == "START":
            self.locctr = int(operands[0])
            self.intermediate_code.append(f"(AD,01) (C,{self.locctr})")

        elif opcode == "END":
            self.intermediate_code.append(f"(AD,02)")

        elif opcode == "ORIGIN":
            self.locctr = int(operands[0])
            self.intermediate_code.append(f"(AD,03) (C,{self.locctr})")

        elif opcode == "EQU":
            value = self.symbol_table.get_address(operands[0])
            self.symbol_table.add_symbol(label, value)
            self.intermediate_code.append(f"(AD,04) (S,{operands[0]})")

        elif opcode == "DS":
            size = int(operands[0])
            self.symbol_table.add_symbol(label, self.locctr)
            self.intermediate_code.append(f"(DL,01) (C,{size})")
            self.locctr += size

        elif opcode == "DC":
            value = int(operands[0])
            self.symbol_table.add_symbol(label, self.locctr)
            self.intermediate_code.append(f"(DL,02) (C,{value})")
            self.locctr += 1

        elif opcode in self.imperative_statements:
            code = f"(IS,{self.imperative_statements[opcode]})"
            reg_code = f"(R,{self.registers.get(operands[0], 0)})"
            mem_op = operands[1]
            self.symbol_table.add_symbol(mem_op)
            mem_code = f"(S,{mem_op})"
            self.intermediate_code.append(f"{code} {reg_code} {mem_code}")
            self.locctr += 1

    def pass_one(self, lines):
        for line in lines:
            parts = line.strip().split()
            if len(parts) == 3:
                label, opcode, ops = parts
            elif len(parts) == 2:
                label = ""
                opcode, ops = parts
            else:
                continue

            operands = [op.strip() for op in ops.split(",")] if ops else []
            self.process_line(label, opcode, operands)

    def display(self):
        print("Intermediate Code:")
        for line in self.intermediate_code:
            print(line)
        self.symbol_table.display()


# -------------------------------
# PASS 2: PassTwoAssembler (newly added)
# -------------------------------
class PassTwoAssembler:
    def __init__(self, intermediate_code, symbol_table):
        self.intermediate_code = intermediate_code
        self.symbol_table = symbol_table
        self.machine_code = []

    def generate_machine_code(self):
        lc = 0  # location counter

        for line in self.intermediate_code:
            parts = line.split()

            # Skip Assembler Directives
            if "(AD" in parts[0]:
                if "(AD,01)" in parts[0] or "(AD,03)" in parts[0]:
                    lc = int(parts[-1].split(',')[1].strip(')'))
                continue

            # Imperative Statements (IS)
            elif "(IS" in parts[0]:
                opcode = parts[0][4:-1]      # e.g., 01
                reg = parts[1][3:-1]         # e.g., 1
                sym = parts[2][3:-1]         # e.g., NUM
                addr = self.symbol_table.get(sym, 0)
                self.machine_code.append(f"{lc}\t{opcode}\t{reg}\t{addr}")
                lc += 1

            # DS Directive (reserve space)
            elif "(DL,01)" in line:
                size = int(parts[-1].split(',')[1].strip(')'))
                lc += size

            # DC Directive (constant)
            elif "(DL,02)" in line:
                value = int(parts[-1].split(',')[1].strip(')'))
                self.machine_code.append(f"{lc}\t00\t0\t{value}")
                lc += 1

    def display(self):
        print("\nMachine Code:")
        print("LC\tOpcode\tReg\tOperand")
        for line in self.machine_code:
            print(line)


# -------------------------------
# INPUT PROGRAM
# -------------------------------
input_program = [
    "START 100",
    "LOOP MOV AREG, NUM",
    "ADD BREG, VALUE",
    "SUB CREG, TEMP",
    "ORIGIN 105",
    "DATA DS 2",
    "CONST DC 5",
    "TEMP DS 1",
    "VALUE DC 10",
    "NUM DC 20",
    "END"
]


# -------------------------------
# EXECUTION
# -------------------------------
assembler1 = AssemblerPassOne()
assembler1.pass_one(input_program)
assembler1.display()

assembler2 = PassTwoAssembler(assembler1.intermediate_code, assembler1.symbol_table.table)
assembler2.generate_machine_code()
assembler2.display()
