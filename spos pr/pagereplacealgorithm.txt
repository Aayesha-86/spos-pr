# FIFO | OPTIMAL | LRU (with user input)
# ======================================
from collections import deque, OrderedDict

# ---------------- FIFO ----------------
def fifo_page_replacement(pages, capacity):
    page_queue = deque(maxlen=capacity)
    page_faults = 0
    print("\n--- FIFO PAGE REPLACEMENT ---")

    for page in pages:
        if page not in page_queue:
            print(f"Page {page} loaded into memory.")
            page_queue.append(page)
            page_faults += 1
        else:
            print(f"Page {page} already in memory.")

    print(f"\nTotal Page Faults (Misses): {page_faults}")
    print(f"Final Pages in Memory: {list(page_queue)}")


# ---------------- OPTIMAL ----------------
def optimal_page_replacement(pages, capacity):
    page_faults = 0
    page_frames = [-1] * capacity
    print("\n--- OPTIMAL PAGE REPLACEMENT ---")

    for i in range(len(pages)):
        if pages[i] not in page_frames:
            if -1 in page_frames:
                index = page_frames.index(-1)
                page_frames[index] = pages[i]
            else:
                future_occurrences = {page: float('inf') for page in page_frames}
                for j in range(i + 1, len(pages)):
                    if pages[j] in future_occurrences and future_occurrences[pages[j]] == float('inf'):
                        future_occurrences[pages[j]] = j

                page_to_replace = max(future_occurrences, key=future_occurrences.get)
                index = page_frames.index(page_to_replace)
                page_frames[index] = pages[i]

            print(f"Page {pages[i]} loaded into memory.")
            page_faults += 1
        else:
            print(f"Page {pages[i]} already in memory.")

    print(f"\nTotal Page Faults: {page_faults}")
    print(f"Final Pages in Memory: {page_frames}")


# ---------------- LRU ----------------
class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity

    def refer(self, page):
        if page in self.cache:
            self.cache.move_to_end(page)
        else:
            if len(self.cache) >= self.capacity:
                self.cache.popitem(last=False)
            self.cache[page] = None


def lru_page_replacement(pages, capacity):
    lru_cache = LRUCache(capacity)
    page_faults = 0
    print("\n--- LRU PAGE REPLACEMENT ---")

    for page in pages:
        if page not in lru_cache.cache:
            print(f"Page {page} loaded into memory.")
            page_faults += 1
        else:
            print(f"Page {page} already in memory.")
        lru_cache.refer(page)

    print(f"\nTotal Page Faults: {page_faults}")
    print(f"Final Pages in Memory: {list(lru_cache.cache.keys())}")


# ---------------- MAIN PROGRAM ----------------
if __name__ == "__main__":
    print("=== PAGE REPLACEMENT ALGORITHMS ===")

    # Take input for page reference string
    n = int(input("\nEnter number of pages in reference string: "))
    pages = []
    for i in range(n):
        page = int(input(f"Enter page number {i + 1}: "))
        pages.append(page)

    # Take input for memory capacity
    capacity = int(input("\nEnter number of frames in memory: "))

    # Menu-driven choice
    while True:
        print("\n--- MENU ---")
        print("1. FIFO Page Replacement")
        print("2. Optimal Page Replacement")
        print("3. LRU Page Replacement")
        print("4. Exit")

        choice = int(input("Enter your choice: "))

        if choice == 1:
            fifo_page_replacement(pages, capacity)
        elif choice == 2:
            optimal_page_replacement(pages, capacity)
        elif choice == 3:
            lru_page_replacement(pages, capacity)
        elif choice == 4:
            print("\nExiting... Thank you!")
            break
        else:
            print("Invalid choice! Please try again.")
